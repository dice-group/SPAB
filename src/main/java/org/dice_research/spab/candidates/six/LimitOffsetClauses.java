package org.dice_research.spab.candidates.six;

import java.util.List;

import org.dice_research.spab.input.Input;

/**
 * LimitOffsetClauses ::= LimitClause OffsetClause? | OffsetClause LimitClause?
 * 
 * LimitClause ::= 'LIMIT' INTEGER
 * 
 * OffsetClause ::= 'OFFSET' INTEGER
 * 
 * Generated by {@link SolutionModifier}
 * 
 * @see https://www.w3.org/TR/sparql11-query/#rLimitOffsetClauses
 * 
 * @author Adrian Wilke
 */
public class LimitOffsetClauses extends Expression {

	enum Type {
		INITIAL, LIMIT, OFFSET, REFINED
	};

	protected Type type;

	public LimitOffsetClauses() {
		// Default constructor is empty, as all contents are optional
		// TODO: Results in empty (and maybe duplicate in other case) regular
		// expression.
		super();
		type = Type.INITIAL;
	}

	public LimitOffsetClauses(Expression origin) {
		super(origin);
		type = ((LimitOffsetClauses) origin).type;
	}

	@Override
	protected Expression createInstance(Expression origin) {
		return new LimitOffsetClauses(origin);
	}

	@Override
	protected void addRegex(StringBuilder stringBuilder) {
		addSequenceToRegex(stringBuilder);
	}

	@Override
	public List<Expression> getRefinements(Input input) {

		List<Expression> refinements = super.getRefinements(input);
		if (type.equals(Type.INITIAL)) {
			LimitOffsetClauses refinement;

			refinement = new LimitOffsetClauses(this);
			refinement.type = Type.LIMIT;
			refinement.sequence.add(new LimitClause());
			refinements.add(refinement);

			refinement = new LimitOffsetClauses(this);
			refinement.type = Type.OFFSET;
			refinement.sequence.add(new OffsetClause());
			refinements.add(refinement);

			type = Type.REFINED;
		} else if (type.equals(Type.LIMIT)) {
			LimitOffsetClauses refinement;

			refinement = new LimitOffsetClauses(this);
			refinement.type = Type.REFINED;
			refinement.sequence.add(new OffsetClause());
			refinements.add(refinement);

			type = Type.REFINED;
		} else if (type.equals(Type.OFFSET)) {
			LimitOffsetClauses refinement;

			refinement = new LimitOffsetClauses(this);
			refinement.type = Type.REFINED;
			refinement.sequence.add(new LimitClause());
			refinements.add(refinement);

			type = Type.REFINED;
		}
		return refinements;
	}
}