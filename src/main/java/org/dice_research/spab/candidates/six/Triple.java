package org.dice_research.spab.candidates.six;

import java.util.List;
import java.util.regex.Pattern;

import org.dice_research.spab.input.Input;

/**
 * Triple refining itself based on input resources.
 * 
 * Generated by {@link TriplesBlock}.
 * 
 * @author Adrian Wilke
 */
public class Triple extends Expression {

	/**
	 * EMPTY: Only empty placeholder.
	 * 
	 * GENERIC: One resource inside triple.
	 * 
	 * FULL: S, P, O can contain resources.
	 */
	public static enum Type {
		EMPTY, GENERIC, FULL
	}

	public static boolean generateFullTriples = true;

	protected Type type;
	protected String resource;
	protected String subject;
	protected String predicate;
	protected String object;

	public Triple() {
		type = Type.EMPTY;
	}

	public Triple(Expression origin) {
		super(origin);

		Triple castedOrigin = (Triple) origin;
		type = castedOrigin.type;
		resource = castedOrigin.resource;
		subject = castedOrigin.subject;
		predicate = castedOrigin.predicate;
		object = castedOrigin.object;
	}

	@Override
	protected Expression createInstance(Expression origin) {
		return new Triple(origin);
	}

	@Override
	protected void addRegex(StringBuilder stringBuilder) {

		if (type.equals(Type.EMPTY)) {
			// Empty triple represented by wild-card
			stringBuilder.append(".*");

		} else if (type.equals(Type.GENERIC)) {
			// Generic triple represented by resource
			stringBuilder.append(".*");
			stringBuilder.append(Pattern.quote("<" + resource + ">"));
			stringBuilder.append(".*");

		} else if (type.equals(Type.FULL)) {
			// Fill triple represented by resources and wild-cards
			if (subject != null) {
				stringBuilder.append(Pattern.quote("<" + subject + ">"));
			} else {
				stringBuilder.append(".*");
			}
			stringBuilder.append(" ");
			if (predicate != null) {
				stringBuilder.append(Pattern.quote("<" + predicate + ">"));
			} else {
				stringBuilder.append(".*");
			}
			stringBuilder.append(" ");
			if (object != null) {
				stringBuilder.append(Pattern.quote("<" + object + ">"));
			} else {
				stringBuilder.append(".*");
			}
		}
	}

	@Override
	public List<Expression> getRefinements(Input input) {
		List<Expression> refinements = getRefinementsOfSequence(input);

		if (type.equals(Type.EMPTY)) {
			for (String resource : input.getResources()) {
				// (*) -> (R)
				Triple triple = new Triple(this);
				triple.type = Type.GENERIC;
				triple.resource = resource;
				refinements.add(triple);
			}

		} else if (type.equals(Type.GENERIC) && generateFullTriples) {
			// (R) -> (S--)
			refinements.add(createFullTriple(resource, null, null));
			// (R) -> (-P-)
			refinements.add(createFullTriple(null, resource, null));
			// (R) -> (--O)
			refinements.add(createFullTriple(null, null, resource));

		} else if (type.equals(Type.FULL) && generateFullTriples) {
			for (String resource : input.getResources()) {
				int components = countComponents();
				if (components == 1) {
					if (subject != null) {
						// (S--) -> (SP-)
						refinements.add(createFullTriple(null, resource, null));
					} else if (predicate != null) {
						// (-P-) -> (-PO)
						refinements.add(createFullTriple(null, null, resource));
					} else if (object != null) {
						// (--O) -> (S-O)
						refinements.add(createFullTriple(resource, null, null));
					}
				} else if (components == 2 && subject != null && predicate != null) {
					// (SP-) -> (SPO)
					refinements.add(createFullTriple(null, null, resource));
				}

			}
		}

		return refinements;
	}

	/**
	 * Returns number of set S, P, O.
	 */
	protected int countComponents() {
		if (!type.equals(Type.FULL)) {
			throw new RuntimeException("Wrong triple type.");
		}
		int counter = 0;
		if (subject != null) {
			counter++;
		}
		if (predicate != null) {
			counter++;
		}
		if (object != null) {
			counter++;
		}
		return counter;
	}

	/**
	 * Creates copy of triple using {@link Triple#Triple(Expression)}. Updates S, P,
	 * O, if not null.
	 */
	protected Triple createFullTriple(String subject, String predicate, String object) {
		if (!type.equals(Type.GENERIC) && !type.equals(Type.FULL)) {
			throw new RuntimeException("Wrong triple type.");
		}
		Triple triple = new Triple(this);
		triple.type = Type.FULL;
		if (subject != null) {
			triple.subject = subject;
		}
		if (predicate != null) {
			triple.predicate = predicate;
		}
		if (object != null) {
			triple.object = object;
		}
		return triple;
	}
}